function [baseline, doPupil] = get_baseline_concBlocks(b, t, doPupil)
% b = block generated by generateGenBlock
% t as loaded by loadSVDfiles; so timepoints from imaging
%
% written by Elina Jacobs, ULC Cortexlab

if nargin < 3
    doPupil = false;
end
cB = false;
sameParams = true;

% SetDefaultDirs;
% BehDir   = DIRS.expInfo;
BehDir = '\\zclone.cortexlab.net\Data\expInfo';

ee = [b.evts];
if isfield(b,'trialsPerExp')
    cB = true;
    for iib = 1:size(b.params,2)
        rewD(iib)   = b.params{iib}.rewardDuration;
        negFbD(iib) = b.params{iib}.negFeedbackDuration;
        QP(iib).preSt = b.params{iib}.preStimQP;
        QP(iib).stim  = b.params{iib}.stimQP;
    end
    if range(rewD)==0 && range(negFbD)==0 % && range(preStQP)==0 && range(stQP)==0
        sameParams = true;
    else sameParams = false;
    end
end

pp = [b.params];
if cB
    if sameParams
        pp = pp{1};
    end
end

ntr = b.completedTrials;
Fs  = 1/median(diff(t));

baseline.firstTrialExcluded = false;        % set default to false - will turn true for some old ChoiceWorld datasets

%% note parameters of the baseline
% what happened last, what happens next, whether quiescence was imposed
disp('getting baseline parameters...');
baseline.params = [];

if b.contRecording
    % figure out if feedback and stimulus offset happened at the same time
    posF = find(ee.feedbackValues(1:ntr)>0);
    negF = find(ee.feedbackValues(1:ntr)<0);
    %     if cB
    %         if range(rewD) == 0
    %             ppa = b.params{1};
    %             posFendtimes = ee.feedbackTimes(posF) + ppa.rewardDuration;
    %         else error('you havent written the case for unequal parameters on the same day yet');
    %         end
    %         if range(negFbD) == 0
    %             ppa = b.params{1};
    %             negFendtimes = ee.feedbackTimes(negF) + ppa.negFeedbackDuration;
    %         else error('you havent written the case for unequal parameters on the same day yet');
    %         end
    if sameParams
        posFendtimes = ee.feedbackTimes(posF) + pp.rewardDuration;
        negFendtimes = ee.feedbackTimes(negF) + pp.negFeedbackDuration;
    else error('you havent written the case for unequal parameters on the same day yet');
    end
    feedbackEndTimes = zeros(1,ntr);
    feedbackEndTimes(posF) = posFendtimes;
    feedbackEndTimes(negF) = negFendtimes;
    
    if abs(mean(ee.stimuliOffTimes - feedbackEndTimes)) < 0.01
        baseline.params.preBaseline.stimOffset  = true;
        baseline.params.preBaseline.feedbackEnd = true;
        xx = mean(ee.endTrialTimes - feedbackEndTimes);
        if abs(xx) < 0.01
            trialEndITI = false;
        else
            trialEndITI = true;
        end
    else
        if  mean(ee.stimuliOffTimes - feedbackEndTimes) > 0
            baseline.params.preBaseline.stimOffset  = true;
            baseline.params.preBaseline.feedbackEnd = false;
            xx = mean(ee.endTrialTimes - ee.stimuliOffTimes);
            if abs(xx) < 0.01
                trialEndITI = false;
            else
                trialEndITI = true;
            end
        else baseline.params.preBaseline.stimOffset = false;
            baseline.params.preBaseline.feedbackEnd = true;
            xx = mean(ee.endTrialTimes - feedbackEndTimes);
            if abs(xx) < 0.01
                trialEndITI = false;
            else
                trialEndITI = true;
            end
        end
    end
    baseline.params.preBaseline.recordingOnset      = false;
else
    baseline.params.preBaseline.stimOffset      = false;
    baseline.params.preBaseline.feedbackEnd     = false;
    baseline.params.preBaseline.recordingOnset  = true;
end

% figure out what happened at end of baseline period, stimulus or cue or both?
if mean(([ee.stimuliOnTimes]-[ee.cueOnTimes])) < 0          % stimulus preceded cue
    baseline.params.baselineEnd.stimulusOnset   = true;
    baseline.params.baselineEnd.cueOnset        = false;
elseif mean(([ee.stimuliOnTimes]-[ee.cueOnTimes])) == 0     % stimulus and cue came on simultaneously
    baseline.params.baselineEnd.stimulusOnset   = true;
    baseline.params.baselineEnd.cueOnset        = true;
else
    baseline.params.baselineEnd.stimulusOnset   = false;
    baseline.params.baselineEnd.cueOnset        = true;
end

if sameParams
    % figure out whether quiescence was imposed
    if mean(pp.preStimQP) > 0
        baseline.params.baselineEnd.stimulusQuiesc  = true;
    else baseline.params.baselineEnd.stimulusQuiesc = false;
    end
    if mean(pp.stimQP) > 0
        baseline.params.baselineEnd.quiescImposed   = true;
    else baseline.params.baselineEnd.quiescImposed  = false;
    end
else error('you havent written the case for unequal parameters on the same day yet');
end

%% find baseline onset & offset for each trial
disp('finding baseline onsets and offsets...')

% load timeline
if cB
    
    baselineOnOffTimes = zeros(ntr,2);       % first column is baseline start, second column is baseline end
    if b.contRecording
        baselineOnOffTimes(1,1)  = ee.newTrialTimes(1);     % first trial will always start here
        if trialEndITI      % use last feedback/stim offset as beginning
            if baseline.params.preBaseline.stimOffset
                baselineOnOffTimes(2:end,1) = ee.stimuliOffTimes(1:ntr-1) + 1/Fs;
            elseif baseline.params.preBaseline.feedbackEnd
                baselineOnOffTimes(2:end,1) = feedbackEndTimes + 1/Fs;
            else error('preBaseline parameters not correctly defined');
            end
        else                % use trial end timing as beginning of baseline
            baselineOnOffTimes(2:end,1) = ee.endTrialTimes(1:ntr-1);
        end
        
        if baseline.params.baselineEnd.stimulusOnset
            baselineOnOffTimes(:,2) = ee.stimuliOnTimes(1:ntr) - 1/Fs;
        elseif baseline.params.baselineEnd.cueOnset
            baselineOnOffTimes(:,2) = ee.cueOnTimes(1:ntr) - 1/Fs;
        else error('baselineEnd parameters not correctly defined');
        end
        
    else
        % this section most likely needs debugging, haven't checked it yet
        % (EJ 20170331)
        nExps = length(b.exps);
        for iib = 1:nExps
            load(fullfile(BehDir,b.animal,b.iseries,num2str(b.exps(iib)),strcat(b.iseries,'_',num2str(b.exps(iib)),'_',b.animal,'_Timeline.mat')));
            
            if baseline.params.preBaseline.recordingOnset
                % find baseline onset by finding cam2 onset after each break in imaging
                DAQts = [];
                if cB
                    for iit = 1:nExps
                        if isempty(DAQts)
                            DAQts = tl(iit).Timeline.rawDAQTimestamps;
                            cam2 = tl(iit).Timeline.rawDAQData(:, tl(iit).Timeline.hw.inputs(...
                                strcmp({tl(iit).Timeline.hw.inputs.name},'cam2')).arrayColumn);
                        else
                            DAQts = cat(2,DAQts,tl(iit).Timeline.rawDAQTimestamps);
                            cam2 = cat(1,cam2,tl(iit).Timeline.rawDAQData(:, tl(iit).Timeline.hw.inputs(...
                                strcmp({tl(iit).Timeline.hw.inputs.name},'cam2')).arrayColumn));
                        end
                    end
                else
                    DAQts = Timeline.rawDAQTimestamps;
                    cam2 = Timeline.rawDAQData(:, Timeline.hw.inputs(...
                        strcmp({Timeline.hw.inputs.name},'cam2')).arrayColumn);
                end
                
                % find camera frame timestamps
                cam2diff        = zeros(1,length(cam2));
                cam2diff(2:end) = diff(cam2);
                cam2OnsetsAll   = find(cam2diff>1); %finds the index number within cam2 in which the value jumps up, which corresponds to onset of imaging
                cam2FrameTimes  = DAQts(cam2OnsetsAll);
                clear cam2diff
                
                c2diff      = zeros(1,length(cam2FrameTimes));
                c2diff(1)   = (5);  % arbitrarily set this to higher than 1, as the first value in cam2FrameTimes is the onset of the first trial
                c2diff(2:end) = diff(cam2FrameTimes);
                cam2TrialOnsets = find(c2diff>1); %finds the indices of the trial onsets within cam2FrameTimes
                cam2TrialOnsetFrameTimes = cam2FrameTimes(cam2TrialOnsets);
                clear c2diff
                
                switch b.expType
                    case 'ChoiceWorld'
                        if b.iseries(4) == '5'        % quick hack... most likely this dataset is one of Elina's first ChoiceWorld datasets
                            % then the first trial wasn't recorded
                            baselineOnOffTimes(1) = b.evts.newTrialTimes(1);
                            baselineOnOffTimes(2:end,1) = cam2TrialOnsetFrameTimes(1:ntr-1)';
                        end
                    case 'signals'
                        if length(cam2TrialOnsetFrameTimes) == ntr+1             % last trial incomplete but imaging started
                            baselineOnOffTimes(1:end,1) = cam2TrialOnsetFrameTimes(1:end-1)';
                        else
                            baselineOnOffTimes(1:end,1) = cam2TrialOnsetFrameTimes';
                        end
                end
            else
                error('preBaseline parameters not correctly defined');
            end
            
            if baseline.params.baselineEnd.stimulusOnset
                baselineOnOffTimes(:,2) = ee.stimuliOnTimes(1:ntr) - 1/Fs;
            elseif baseline.params.baselineEnd.cueOnset
                baselineOnOffTimes(:,2) = ee.cueOnTimes(1:ntr) - 1/Fs;
            else error('baselineEnd parameters not correctly defined');
            end
            
            % error('you havent written the case for non-continuous datasets yet!');
        end
    end
    
else
    
    load(fullfile(BehDir,b.animal,b.iseries,b.iexp,strcat(b.iseries,'_',b.iexp,'_',b.animal,'_Timeline.mat')));
    
    baselineOnOffTimes = zeros(ntr,2);       % first column is baseline start, second column is baseline end
    if b.contRecording
        baselineOnOffTimes(1,1)  = ee.newTrialTimes(1);     % first trial will always start here
        if trialEndITI      % use last feedback/stim offset as beginning
            if baseline.params.preBaseline.stimOffset
                baselineOnOffTimes(2:end,1) = ee.stimuliOffTimes(1:ntr-1) + 1/Fs;
            elseif baseline.params.preBaseline.feedbackEnd
                baselineOnOffTimes(2:end,1) = feedbackEndTimes + 1/Fs;
            else error('preBaseline parameters not correctly defined');
            end
        else                % use trial end timing as beginning of baseline
            baselineOnOffTimes(2:end,1) = ee.endTrialTimes(1:ntr-1);
        end
        
        if baseline.params.baselineEnd.stimulusOnset
            baselineOnOffTimes(:,2) = ee.stimuliOnTimes(1:ntr) - 1/Fs;
        elseif baseline.params.baselineEnd.cueOnset
            baselineOnOffTimes(:,2) = ee.cueOnTimes(1:ntr) - 1/Fs;
        else error('baselineEnd parameters not correctly defined');
        end
        
    else
        
        if baseline.params.preBaseline.recordingOnset
            % find baseline onset by finding cam2 onset after each break in imaging
            DAQts = [];
            if cB
                for iit = 1:nExps
                    if isempty(DAQts)
                        DAQts = tl(iit).Timeline.rawDAQTimestamps;
                        cam2 = tl(iit).Timeline.rawDAQData(:, tl(iit).Timeline.hw.inputs(...
                            strcmp({tl(iit).Timeline.hw.inputs.name},'cam2')).arrayColumn);
                    else
                        DAQts = cat(2,DAQts,tl(iit).Timeline.rawDAQTimestamps);
                        cam2 = cat(1,cam2,tl(iit).Timeline.rawDAQData(:, tl(iit).Timeline.hw.inputs(...
                            strcmp({tl(iit).Timeline.hw.inputs.name},'cam2')).arrayColumn));
                    end
                end
            else
                DAQts = Timeline.rawDAQTimestamps;
                cam2 = Timeline.rawDAQData(:, Timeline.hw.inputs(...
                    strcmp({Timeline.hw.inputs.name},'cam2')).arrayColumn);
            end
            
            % find camera frame timestamps
            cam2diff        = zeros(1,length(cam2));
            cam2diff(2:end) = diff(cam2);
            cam2OnsetsAll   = find(cam2diff>1); %finds the index number within cam2 in which the value jumps up, which corresponds to onset of imaging
            cam2FrameTimes  = DAQts(cam2OnsetsAll);
            clear cam2diff
            
            c2diff      = zeros(1,length(cam2FrameTimes));
            c2diff(1)   = (5);  % arbitrarily set this to higher than 1, as the first value in cam2FrameTimes is the onset of the first trial
            c2diff(2:end) = diff(cam2FrameTimes);
            cam2TrialOnsets = find(c2diff>1); %finds the indices of the trial onsets within cam2FrameTimes
            cam2TrialOnsetFrameTimes = cam2FrameTimes(cam2TrialOnsets);
            clear c2diff
            
            switch b.expType
                case 'ChoiceWorld'
                    if b.iseries(4) == '5'        % quick hack... most likely this dataset is one of Elina's first ChoiceWorld datasets
                        % then the first trial wasn't recorded
                        baselineOnOffTimes(1) = b.evts.newTrialTimes(1);
                        baselineOnOffTimes(2:end,1) = cam2TrialOnsetFrameTimes(1:ntr-1)';
                    end
                case 'signals'
                    if length(cam2TrialOnsetFrameTimes) == ntr+1             % last trial incomplete but imaging started
                        baselineOnOffTimes(1:end,1) = cam2TrialOnsetFrameTimes(1:end-1)';
                    else
                        baselineOnOffTimes(1:end,1) = cam2TrialOnsetFrameTimes';
                    end
            end
        else
            error('preBaseline parameters not correctly defined');
        end
        
        if baseline.params.baselineEnd.stimulusOnset
            baselineOnOffTimes(:,2) = ee.stimuliOnTimes(1:ntr) - 1/Fs;
        elseif baseline.params.baselineEnd.cueOnset
            baselineOnOffTimes(:,2) = ee.cueOnTimes(1:ntr) - 1/Fs;
        else error('baselineEnd parameters not correctly defined');
        end
        
        % error('you havent written the case for non-continuous datasets yet!');
    end
end

if baseline.params.preBaseline.recordingOnset    % if recording wasn't continuous, chop off first 200ms at imaging onset as onset causes artefacts
    baselineOnOffTimes(:,1) = baselineOnOffTimes(:,1) + 0.2;
    disp('Non-continuous imaging dataset, chopping off first 200ms of baseline to get rid of onset artefacts');
end

%% find corresponding frames in t/V
% gets indices of frames in V, timepoints in t
bl_Vframes  = interp1(t, 1:numel(t), baselineOnOffTimes, 'nearest');
if isnan(bl_Vframes(1)) || isnan(bl_Vframes(1,2))              % if behavioural block started before recording
    if t(1) > baselineOnOffTimes(1,2)       % first baseline wasn't imaged, therefore exclude first trial
        ntr = ntr-1;
        baselineOnOffTimes = baselineOnOffTimes(2:end,:);
        bl_Vframes         = bl_Vframes(2:end,:);
        baseline.firstTrialExcluded = true;
    else
        bl_Vframes(1)       = 1;
        baselineOnOffTimes(1)    = t(1); % to start the baseline when the actual imaging started
    end
end
while isnan(bl_Vframes(end))         % if behavioural block kept going even though imaging ended
    bl_Vframes          = bl_Vframes(1:end-1,:);
    baselineOnOffTimes  = baselineOnOffTimes(1:end-1,:);
    ntr = ntr-1;
end

xx = diff(bl_Vframes');
maxBLfr = max(xx)+1; clear xx     % this gives the maximum number of frames within a baseline

baseline.OnOffTimes = baselineOnOffTimes;
baseline.V_OnOffFramenumbers = bl_Vframes;

%%
% find corresponding indices of time points in wheel trace
bl_wheelInd = interp1(b.wheel.Times, 1:numel(b.wheel.Times), baselineOnOffTimes, 'nearest');
if isnan(bl_wheelInd(1));
    bl_wheelInd(1) = 1;
end

%% find corresponding frames in pupil/face movie
if isfield(b,'iexp')        % single dataset
    if doPupil
        warning on
        switch b.rigName
            case 'BigRig'
                % loads file called results which contains pupil dimensions as found by Krumin's gui
                if exist(fullfile('\\zserver.cortexlab.net\Data\EyeCamera',b.animal,b.iseries,b.iexp,...
                        strcat([b.iseries],'_',[b.iexp],'_',[b.animal],'_eye_processed.mat')));
                    load(fullfile('\\zserver.cortexlab.net\Data\EyeCamera',b.animal,b.iseries,b.iexp,...
                        strcat([b.iseries],'_',[b.iexp],'_',[b.animal],'_eye_processed.mat')));
                    [eyeFrameTimes, ~] = et.getFrameTimes(b.animal, str2num(b.iseries(b.iseries~='-')), str2num(b.iexp));
                else
                    warning('The pupil results dont exist yet for this experiment, setting do pupil analysis to false');
                    ppa = input('Do you want to run the eye analysis GUI now? Type Y for yes ');
                    if ppa == 'Y'
                        etGUI;
                        keyboard;
                        load(fullfile('\\zserver.cortexlab.net\Data\EyeCamera',b.animal,b.iseries,b.iexp,...
                            strcat([b.iseries],'_',[b.iexp],'_',[b.animal],'_eye_processed.mat')));
                        [eyeFrameTimes, ~] = et.getFrameTimes(b.animal, str2num(b.iseries(b.iseries~='-')), str2num(b.iexp));
                    else
                        doPupil = false;
                    end
                end
            case 'zgood'   % for Nick's data which has a different name...
                if exist(fullfile('\\zserver.cortexlab.net\Data\EyeCamera',b.animal,b.iseries,b.iexp,'eye_processed.mat'));
                    load(fullfile('\\zserver.cortexlab.net\Data\EyeCamera',b.animal,b.iseries,b.iexp,'eye_processed.mat'));
                    load(fullfile('\\zserver.cortexlab.net\Data\EyeCamera',b.animal,b.iseries,b.iexp,'eye_timeStamps.mat'));
                    eyeFrameTimes = tVid;
                else
                    warning('The pupil results dont exist yet for this experiment, setting do pupil analysis to false');
                    doPupil = false;
                end
        end
    end
    % need to have two "if doPupil" cases cause above, there is an option to
    % set it to false if the analysis results don't exist yet
    if doPupil
        blinks      = find(results.blink==1);
        pupilSize   = [results.area];
        pSnan       = find(isnan(pupilSize));   % some places are NaNs already
        pupilSize(blinks) = NaN;                % get rid of blinks
        pupilSize   = pupilSize(isfinite(pupilSize));
        
        medPS = median(pupilSize);              % get rid of values that are unrealistic
        minPS = find(pupilSize<medPS/4);
        maxPS = find(pupilSize>medPS*5);
        pupilSize(minPS) = NaN; pupilSize(maxPS) = NaN;
        pupilSize   = pupilSize(isfinite(pupilSize));
        
        % low pass filter pupil
        % disp('low pass filtering pupil');
        ppFs        = 1/median(diff(eyeFrameTimes));
        pp_freq     = [0.0001, 1];
        avgPS       = mean(pupilSize);
        zPP         = bsxfun(@minus, pupilSize, avgPS);
        [fb, fa]    = butter(2,pp_freq/(ppFs/2));
        fPupilSize  = filter(fb,fa,zPP);
        fPupilSize  = bsxfun(@plus, fPupilSize, avgPS);
        
        eFT = eyeFrameTimes;
        eFT(blinks) = NaN; eFT(pSnan) = NaN; eFT = eFT(isfinite(eFT));
        eFT(minPS) = NaN; eFT(maxPS) = NaN; eFT = eFT(isfinite(eFT));
        
        % % interpolate pupilSize during blinks
        % pS  = interp1(eFT,pupilSize,eyeFrameTimes,'pchip');
        
        bl_eyeFrames = interp1(eFT, 1:numel(eFT), baselineOnOffTimes,'nearest');
        if isnan(bl_eyeFrames(1));
            bl_eyeFrames(1) = 1;
        end
        if isnan(bl_eyeFrames(1,2));
            bl_eyeFrames(1,2) = 1;
        end
    end
elseif isfield(b,'exps')        % it's concatenated blocks
    ne = length(b.exps);
    for iie = 1:ne
        b.iexp = b.exps(iie);
        
        if doPupil              % set this after the loop start, as even if one of the pupi results exist, it's no use for the concatenated blocks
            switch b.rigName
                case 'BigRig'
                    % loads file called results which contains pupil dimensions as found by Krumin's gui
                    if exist(fullfile('\\zserver.cortexlab.net\Data\EyeCamera',b.animal,b.iseries,b.iexp,...
                            strcat([b.iseries],'_',[b.iexp],'_',[b.animal],'_eye_processed.mat')));
                        load(fullfile('\\zserver.cortexlab.net\Data\EyeCamera',b.animal,b.iseries,b.iexp,...
                            strcat([b.iseries],'_',[b.iexp],'_',[b.animal],'_eye_processed.mat')));
                        [eyeFrameTimes, ~] = et.getFrameTimes(b.animal, str2num(b.iseries(b.iseries~='-')), str2num(b.iexp));
                    else
                        warning('The pupil results dont exist yet for this experiment, setting do pupil analysis to false');
                        doPupil = false;
                    end
                case 'zgood'   % for Nick's data which has a different name...
                    if exist(fullfile('\\zserver.cortexlab.net\Data\EyeCamera',b.animal,b.iseries,b.iexp,'eye_processed.mat'));
                        load(fullfile('\\zserver.cortexlab.net\Data\EyeCamera',b.animal,b.iseries,b.iexp,'eye_processed.mat'));
                        load(fullfile('\\zserver.cortexlab.net\Data\EyeCamera',b.animal,b.iseries,b.iexp,'eye_timeStamps.mat'));
                        eyeFrameTimes = tVid;
                    else
                        warning('The pupil results dont exist yet for this experiment, setting do pupil analysis to false');
                        doPupil = false;
                    end
            end
        end
        
        if doPupil
            blinks      = find(results.blink==1);
            pupilSize   = [results.area];
            pSnan       = find(isnan(pupilSize));   % some places are NaNs already
            pupilSize(blinks) = NaN;                % get rid of blinks
            pupilSize   = pupilSize(isfinite(pupilSize));
            
            medPS = median(pupilSize);              % get rid of values that are unrealistic
            minPS = find(pupilSize<medPS/4);
            maxPS = find(pupilSize>medPS*5);
            pupilSize(minPS) = NaN; pupilSize(maxPS) = NaN;
            pupilSize   = pupilSize(isfinite(pupilSize));
            
            % low pass filter pupil
            % disp('low pass filtering pupil');
            ppFs        = 1/median(diff(eyeFrameTimes));
            pp_freq     = [0.0001, 1];
            avgPS       = mean(pupilSize);
            zPP         = bsxfun(@minus, pupilSize, avgPS);
            [fb, fa]    = butter(2,pp_freq/(ppFs/2));
            fPupilSize  = filter(fb,fa,zPP);
            fPupilSize  = bsxfun(@plus, fPupilSize, avgPS);
            
            eFT = eyeFrameTimes;
            eFT(blinks) = NaN; eFT(pSnan) = NaN; eFT = eFT(isfinite(eFT));
            eFT(minPS) = NaN; eFT(maxPS) = NaN; eFT = eFT(isfinite(eFT));
            
            % % interpolate pupilSize during blinks
            % pS  = interp1(eFT,pupilSize,eyeFrameTimes,'pchip');
            
            bl_eyeFrames = interp1(eFT, 1:numel(eFT), baselineOnOffTimes,'nearest');
            if isnan(bl_eyeFrames(1));
                bl_eyeFrames(1) = 1;
            end
            if isnan(bl_eyeFrames(1,2));
                bl_eyeFrames(1,2) = 1;
            end
            
            if ~exist(fPS)
                fPS     = fPupilSize;
                eFTall  = eFT;
                bl_eF   = bl_eyeFrames;
            else
                fPS     = cat(1,fPS,fPupilSize);
                eFTall  = cat(1,eFTall,eFT);
                bl_eF   = cat(1,bl_ef,bl_eyeFrames);
            end
        end
        
    end
    
    if doPupil
        % rename the concatenated blocks to agree with single experiment namings
        fPupilSize  = fPS;
        eFT         = eFTall;
        bl_eyeFrames = bl_eF;
    end
    
end

%%
% interpolate wheel and pupil to match timestamps in t
disp('finding baseline wheel and pupil values...');

baselineWheel = NaN(ntr,maxBLfr);   % each row is a trial
baselinePupil = NaN(ntr,maxBLfr);
baselineTimes = NaN(ntr,maxBLfr);
for iit = 1:ntr
    thisT   = t(bl_Vframes(iit,1):bl_Vframes(iit,2));
    baselineTimes(iit,1:length(thisT)) = thisT;
    
    % find wheel trajectory during baseline time of trial iit
    thisWh  = interp1(b.wheel.Times(bl_wheelInd(iit,1):bl_wheelInd(iit,2)),...
        b.wheel.Values(bl_wheelInd(iit,1):bl_wheelInd(iit,2)),thisT,'pchip');
    % baselineWheel(iit,1:length(thisT)) = thisWh - thisWh(1);        % set each baseline to start at 0 position for wheel
    baselineWheel(iit,(maxBLfr-length(thisT))+1:end) = thisWh - thisWh(end);
    
    if doPupil
        % find pupil dynamics
        if bl_eyeFrames(iit,1) == bl_eyeFrames(iit,2)   % mouse was probably whisking/blinking throughout baseline so therefore there is no pupil measurement
            thisPp = zeros(1,length(thisT));
        else
            thisPp  = interp1(eFT(bl_eyeFrames(iit,1):bl_eyeFrames(iit,2)),...
                fPupilSize(bl_eyeFrames(iit,1):bl_eyeFrames(iit,2)),thisT,'pchip');
        end
        %         baselinePupil(iit,1:length(thisT)) = thisPp;
        baselinePupil(iit,(maxBLfr-length(thisT))+1:end) = thisPp;      % to have them all aligned to end of baseline, as beginning of baseline is more various
    end
    
end

baseline.Vtimepoints    = baselineTimes;
baseline.wheelValues    = baselineWheel;
baseline.pupilTraces    = baselinePupil;

disp('done');

end